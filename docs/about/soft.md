**职业生涯规划**

短期规划：第一、我希望能做一个真正好用的面向用户的产品，第二、我希望能在持续的业务开发中在 1-3 年内得到团队信任成为骨干员工帮助团队进步并且最大化自己的价值。长期规划：持续提升项目、团队管理能力，逐步承担业务线负责人职责，技术驱动产品。

技术维度上的规划：一方面是实践型技术，比如 AI、Web3、Rust 底层基建、前端一直在卷的框架，这种技术基本只要投入时间成本就能完成的，会根据自己的兴趣和时间去持续学习。
还有就是提升技术的广度，最近在想卷深度的意义，有了 AI 之后好像意义也没那么大了，但是技术广度还是需要的，比如想从 0-1 做一个产品，产品维度、开发维度、测试、部署、运维、监控、安全，我希望是广度优先，逐步具备把控和架构的能力，深度的话就是沉没成本，根据业务需要再去挖就好了。
另一方面是开放型技术，比如文档能力、开源社区、整理个人知识库的能力。

**团队管理与协作**

- 问题： 你是如何带领团队进行技术选型和决策的？在技术选型过程中，你会如何平衡技术的先进性与团队的实际能力？
- 首先技术选型一定要尽可能在简单的维度上考虑，而不是一味的追求技术的先进性。比如 RxJS，装饰器，反转控制等，当然不是说这些技术不好，只是在项目维护上，我们应该尽可能减少后续的维护成本和技术债、技术复杂度。如果是底层的 SDK，技术选型不会说是开会进行讨论，更好的方式就是花几个小时做 AB Test，通过 benchmark 测试来选择性能更优，成本更低的方案。其次，技术的可行性、社区支持和未来发展趋势，然后根据项目的规模、性能需求和长期可维护性来选择合适的技术。如果是一些新兴技术，我会更注重其稳定性、可扩展性以及是否能够快速融入现有团队的技术栈。在选型过程中，我也会考虑培训和技术债务的控制，确保新技术能够被团队成员顺利掌握并应用。

**下一份工作期望**

- 技术上面临更具挑战性的项目，也希望能够在团队中继续扩展我的技术能力，了解不同的业务场景。
- 希望我的团队氛围能够活泼热情，积极向上且融洽。能重视个人成长，给予个人成长发挥的空间。无论是技术层面、管理层面或是其他各个方面。多多尝试新事物。那我也愿意在团队中分享我的经验，也可以从别人那里学习的更多。与此同时我也可以发挥我项目管理方面的优势，帮助团队获得更好的结果。

**个人优点和缺点**

优点和优势：认真负责，会积极主动推动项目，在质量保证和可控的情况下愿意尝试将新技术运用在项目中。会在项目结束后总结经验教训并对自己做一个复盘。学习过项目管理的知识，拥有软考证书，能用项目管理的经验和理论反哺业务。
缺点：在处理并行的多任务的时候有时候无法平衡好各个任务的优先级，有时会让我感到焦虑。这些我会在工作过程中通过一些诸如文档沉淀、工具等方法帮助我更有条理和高效地处理问题。我在人多的场合讲话时会感到紧张和不自在，比如在做大范围团队分享时，这个是我需要锻炼和练习的点。所以我有在看一些前端大佬的视频，学习他们的讲话风格和思维模式。

有什么问题想问

- 团队的业务？
- 公司的开发流程是怎样的？如何进行团队协作？

**技术难点**

高密度的去开发项目框架和构建器，在做小程序框架的时候，从 0-1 去接触了核心框架开发，构建器开发，之前做 Hybrid、做 RN 都是面向前端，这次会从整体跨端角度去设计功能，从功能实现、性能稳固、易用度、合理性、业界通用做法等多方面考量。也需要有一些自己的思考和创新。
前期在项目 1.0 阶段为了项目进度，有些功能考虑不足，比如一些 API 设计会出现 break change 的情况。如果再做一遍，首先要避免 break change 的情况，对于后期一定会做改造的点，在前期做好 plan b。比如在设计 Ray 时，最开始定位的是一个跨端框架，因此做了很多 RN 相关的抹平工作还不好兼容。后续抛弃了 RN 端的跨端后就产生了很多 break change。这些需要在框架设计前期就要思考好。

**技术热爱与持续学习**

GitHub 要会每天都看，上班忙回家还要带娃的情况下，有个很好的方式，就是感兴趣的或者最火的项目，就点个 watch，每天抽个十来分钟，批阅奏折一样过一遍他们每天写了什么东西，既能保持技术的敏感度，也能有时候可以学到一些新东西。

**团队协作与领导力**

如果是同一个团队的小伙伴，那没任何问题，就是多沟通交流多分享。如果是跨团队的小伙伴，首先一定要充分了解对方的业务和实际情况，他业务中负责做什么，做事习惯，什么类型的人最好了解一下，然后多沟通多交流多分享，哈哈，开朗的面对工作和同事，保持热度和真诚吧，时间久了熟络了知道彼此自然而然的合拍了，效率会高很多。

**关于 AI**

1. 我们当然要拥抱 AI，但是没必要任何场景都套 AI，可以想想，但是不必把大部分精力放在这里，坚持长期主义，比如现在直播火的小红书、抖音，最开始做直播的也不是他们，还是要基本盘稳，坚持长期主义，做一直以来都坚持的事。
2. 还是要拥抱变化，这点我认为跟上一个观点并不冲突，比如作为开发，我们的持续学习不能只跟热点，但是还是要看到趋势，比如生产力提高 windsurf、cursor 要用，马上用，充钱用，先把自己的生产力提高上来，然后就有时间去思考为什么和怎么做了，但是 AI Agent、RAG、LLM 这些可以晚点去学，让子弹飞一会，AI 的时代 迭代太快，生产力跟上之后，再去思考。
3. 还有就是一定是要养成和 AI 结对编程的习惯，做 AI 的学生而不是 AI 的主人，不然真的太容易思维钝化了，反而容易被淘汰。

未来 AI 的方向，一定是面向用户的好的产品，现在更多的是开发者驱动，生产力工具，因为互联网从业者一定是更敏感的。
现在有的比如学习辅导、医疗诊断、心理方向、智能硬件、内容创作这些。

**项目管理**
首先确保团队都在一个维度，风险控制，合理分配和利用资源、时间管理、小团队就阶段性复盘，持续改进。

---

### **CTO/总监面试常见问题及应对方向**

CTO/总监层面试更关注 **技术战略思维、系统设计深度、业务影响力、团队协作能力** 以及对公司业务的契合度。以下是可能的问题分类及应对建议：

---

### **一、技术深度与架构设计**

### 1. **复杂系统设计**

- **问题示例**：
  “如果让你设计一个高可用、可扩展的自动化流程引擎（类似影刀 RPA 的核心），你会如何设计架构？”
- **应对方向**：
  - **分层设计**：拆解为流程编排层（DSL 解析）、执行引擎层（沙箱隔离）、调度层（分布式任务队列）、监控层（实时日志/告警）。
  - **关键技术点**：沙箱安全隔离（如 WebAssembly）、容错机制（重试/回滚）、性能优化（冷启动加速）。
  - **结合经验**：关联涂鸦小程序的安全沙箱、低代码平台动态执行能力。

### 2. **技术选型与权衡**

- **问题示例**：
  “在小程序基础库开发中，为何选择自研双线程模型而非直接复用 WebView？”
- **应对方向**：
  - **业务需求**：IoT 场景对性能（渲染效率）和安全性（XSS 防御）的高要求。
  - **技术对比**：WebView 在复杂交互场景的性能瓶颈，自研模型可精细化控制通信（如 MessageBridge）。
  - **成果验证**：通过压测数据（如 FPS 提升 30%）和稳定性指标（崩溃率<0.1%）佐证。

### 3. **性能优化实战**

- **问题示例**：
  “你提到将小程序构建耗时从 5 分钟压缩到 30 秒，具体如何实现？若进一步优化，方向是什么？”
- **应对方向**：
  - **分层优化**：
    1. **工具链升级**（esbuild 替换 Webpack）；
    2. **缓存策略**（持久化 Hash 缓存）；
    3. **并行化**（模板/样式/脚本编译分离）。
  - **未来方向**：增量编译、分布式构建（如利用 CI/CD 集群）。

---

### **二、领导力与团队协作**

### 1. **技术驱动业务**

- **问题示例**：
  “如何说服业务方接受你的技术方案（如低代码平台）？若遇到阻力如何处理？”
- **应对方向**：
  - **数据说服**：通过 MVP 验证核心价值（如某业务交付周期从 2 周 →2 天）。
  - **渐进式落地**：优先在非核心业务试点，用实际收益推动全面落地。
  - **案例参考**：涂鸦低代码平台初期通过“快速生成营销活动页”切入，逐步扩展至 IoT 控制场景。

### 2. **跨团队协同**

- **问题示例**：
  “在跨端 API 插件体系开发中，如何推动客户端、服务端团队配合？”
- **应对方向**：
  - **标准化协作**：制定 API 设计规范（OpenAPI Schema）和文档自动化生成工具。
  - **工具赋能**：提供 CLI 工具一键生成多端 SDK，降低协作成本。
  - **利益绑定**：通过数据展示效率提升（如客户端开发耗时减少 50%）。

### 3. **团队能力建设**

- **问题示例**：
  “如何提升团队的技术氛围或创新能力？”
- **应对方向**：
  - **机制设计**：技术分享会、Hackathon、开源贡献激励。
  - **案例参考**：在涂鸦推动技术专栏和 Codelabs 教程，提升团队技术影响力。

---

### **三、业务与战略思维**

### 1. **行业洞察**

- **问题示例**：
  “如何看待 RPA（机器人流程自动化）的未来趋势？影刀的核心竞争力是什么？”
- **应对方向**：
  - **趋势判断**：
    - 从“规则驱动”转向“AI 驱动”（如结合 LLM 实现自然语言生成自动化流程）。
    - 从企业级工具向中小企业及个人开发者渗透（参考影刀的“平民化”战略）。
  - **影刀优势**：
    - 产品易用性（低代码+录制功能）；
    - 垂直场景深耕（电商、财务等）；
    - 开发者生态建设（插件市场、社区运营）。

### 2. **技术赋能业务**

- **问题示例**：
  “如果你加入影刀，如何将你的技术经验应用到 RPA 产品中？”
- **应对方向**：
  - **技术迁移**：
    - 低代码经验 → 优化影刀可视化流程设计器；
    - 跨端 API 体系 → 增强 RPA 多端（Web/桌面/移动）调度能力；
    - 安全沙箱 → 提升自动化脚本执行的安全性。
  - **创新方向**：探索 AI+自动化（如用 GPT 解析用户需求生成自动化脚本）。

---

### **四、行为与软技能**

### 1. **高压决策**

- **问题示例**：
  “请分享一个在资源紧张下成功交付项目的案例。”
- **应对方向**（STAR 法则）：
  - **Situation**：涂鸦小程序初期需在 3 个月内支持核心业务上线。
  - **Task**：团队人力不足，需同时完成基础库和构建器开发。
  - **Action**：
    1. 优先级拆分（MVP 核心功能优先）；
    2. 引入开源工具链（esbuild）减少自研成本；
    3. 每日站会同步风险。
  - **Result**：按时上线，支撑首个月 100 万设备接入。

### 2. **失败与复盘**

- **问题示例**：
  “请分享一个技术决策失败的案例，你从中学到了什么？”
- **应对方向**：
  - **案例选择**：早期在 RN 热更新中未考虑客户端兼容性，导致部分用户白屏。
  - **复盘结论**：
    1. 灰度发布策略的必要性；
    2. 自动化测试覆盖率的重要性；
    3. 建立实时监控告警体系。

---

### **五、反问环节建议问题**

1. **战略方向**：
   “影刀未来在 AI 与自动化结合的技术规划是什么？如何平衡产品易用性与技术深度？”
2. **团队挑战**：
   “当前团队在技术落地过程中遇到的最大挑战是什么？希望候选人如何帮助解决？”
3. **成功标准**：
   “您希望这个岗位的候选人在 6 个月内实现哪些关键目标？”

---

### **注意事项**

1. **数据驱动**：用“效率提升 40%”“支撑 100 万设备”等量化结果证明能力。
2. **业务结合**：提前研究影刀的产品（如 RPA Studio、插件生态），在回答中关联其业务场景。
3. **价值观传递**：强调“技术解决真实问题”的理念，与影刀“让自动化触手可及”的使命契合。

通过以上准备，你不仅能展示技术深度，还能体现战略思维和业务敏感度，大幅提升通过率。

---

以下是 **15 个 CTO/总监面试高频问题** 及回答方向，结合你的技术背景和影刀业务场景设计：

---

### **一、技术深度与架构设计**

1. **“设计一个自动化流程引擎（如影刀 RPA 的核心），如何保障高并发下的稳定性和安全性？”**
   - **方向**：分層架構（调度层、执行层、监控层）、沙箱隔离（WebAssembly）、熔断机制、分布式任务队列（如 Kafka）。
2. **“在小程序双线程模型中，如何优化逻辑线程与渲染线程的通信效率？”**
   - **方向**：MessageBridge 的序列化优化（二进制替代 JSON）、批量消息合并、事件订阅机制。
3. **“如果让你设计一个低代码平台，你会如何平衡灵活性和性能？”**
   - **方向**：动态渲染策略（按需加载）、预编译优化、DSL 分层设计（基础组件+扩展插件）。

---

### **二、技术决策与权衡**

1. **“为何在小程序构建器中用 esbuild 替代 Webpack？若未来迁移到 Rust 工具链，需要考虑哪些因素？”**
   - **方向**：构建速度 vs 生态兼容性、插件迁移成本、团队学习曲线。
2. **“在跨端 API 插件体系中，为何选择 TS DSL 而非 JSON Schema 定义接口？”**
   - **方向**：类型安全、开发体验（代码提示）、与现有技术栈整合度。
3. **“RN 热更新方案中，如何权衡全量更新与增量更新？”**
   - **方向**：增量包体积小但维护复杂，需结合业务场景（高频迭代用增量，大版本用全量）。

---

### **三、业务与技术创新**

1. **“如何将你的低代码平台经验赋能影刀的 RPA 产品？”**
   - **方向**：可视化流程编排、AI 生成脚本（如 GPT 解析自然语言指令）、多端执行器调度。
2. **“若让你优化影刀的自动化脚本执行性能，你会从哪些方面入手？”**
   - **方向**：冷启动优化（预加载沙箱）、执行引擎并发控制、资源复用（如连接池）。
3. **“AI 如何与 RPA 结合？请举例说明技术落地方向。”**
   - **方向**：OCR+自动化填报、NLP 解析用户需求生成流程、强化学习优化脚本路径。

---

### **四、团队管理与协作**

1. **“在涂鸦推动跨团队项目时，遇到技术方案分歧如何处理？”**
   - **方向**：数据验证（AB 测试）、最小可行性方案（MVP）试点、高层级技术评审会。
2. **“如何培养团队的技术创新能力？请举例说明。”**
   - **方向**：内部技术分享会、Hackathon 机制、开源贡献激励（如涂鸦的 Codelabs）。
3. **“若团队中有成员对新技术（如 AI）有抵触，如何推动技术升级？”**
   - **方向**：培训+实战结合（如用 AI 简化其重复工作）、展示 ROI（效率提升数据）。

---

### **五、业务与行业洞察**

1. **“影刀的核心用户是企业和开发者，如何通过技术提升两者的体验？”**
   - **方向**：企业侧-流程编排可视化；开发者侧-开放 API 和插件生态。
2. **“RPA 领域未来的技术竞争点是什么？影刀应如何布局？”**
   - **方向**：AI 驱动自动化（如自主决策脚本）、云端一体化、垂直场景深耕（如电商客服自动化）。
3. **“如果你加入影刀，6 个月内希望实现什么技术目标？”**
   - **方向**：
     1. 优化核心引擎性能（如脚本执行速度提升 30%）；
     2. 搭建开发者生态基础（插件市场、文档体系）；
     3. 探索 AI+自动化原型（如 Demo 级智能脚本生成）。

---

### **回答策略**

1. **STAR 法则**：用“背景-行动-结果”结构化表达，如问题 10：“在跨端 API 项目中（S），客户端团队担心维护成本（T），我通过 CLI 工具生成 80%代码（A），最终推动方案落地（R）。”
2. **数据佐证**：如“构建速度提升 80%”“热更新成功率 95%”。
3. **业务关联**：将技术方案与影刀场景结合，如“沙箱隔离经验可增强 RPA 脚本执行安全性”。
4. **价值观传递**：强调“技术解决真实问题”，如“通过低代码让非技术人员享受自动化价值”。

---

关于 AI

1. 我们当然要拥抱 AI，但是没必要任何场景都套 AI，可以想想，但是不必把大部分精力放在这里，坚持长期主义，比如现在直播火的小红书、抖音，最开始做直播的也不是他们，还是要基本盘稳，坚持长期主义，做一直以来都坚持的事。
2. 还是要拥抱变化，这点我认为跟上一个观点并不冲突，比如作为开发，我们的持续学习不能只跟热点，但是还是要看到趋势，比如生产力提高 windsurf、cursor 要用，马上用，充钱用，先把自己的生产力提高上来，然后就有时间去思考为什么和怎么做了，但是 AI Agent、RAG、LLM 这些可以晚点去学，让子弹飞一会，AI 的时代 迭代太快，生产力跟上之后，再去思考。
3. 还有就是一定是要养成和 AI 结对编程的习惯，做 AI 的学生而不是 AI 的主人，不然真的太容易思维钝化了，反而容易被淘汰。

未来 AI 的方向，一定是面向用户的好的产品，现在更多的是开发者驱动，生产力工具，因为互联网从业者一定是更敏感的。
现在有的比如学习辅导、医疗诊断、心理方向、智能硬件、内容创作这些。

1. 整理自我介绍，突出项目的价值，包括我在整个的项目中承担了什么角色，达到了什么结果。
2. 考虑重新出发，你的动机是什么？
3. 控制自我介绍的时间和交流空间，过去的能力和优势、

Http
http 明文传输 80 https tls/ssl 加密 443
http2 多路复用 头部压缩 二进制格式传输 http1.1 长链接单向通道
强缓存 expires + cache-control 有无过期 - 协商缓存 etag 文件指纹+last-modified 查看资源是否已更新 304
CORS 跨域 浏览器同源策略 ngnix 反向代理
2xx 成功 3xx 重定向 304 协商缓存 4xx 客户端错误 5xx 服务器错误  
JS
值类型 - 栈内存 - 空间固定 - 复制值本身
引用类型 -堆内存 - 动态空间 - 复制指针
作用域 - 闭包（外部作用域访问内部作用域，实现封装、ES module 的基础，通过闭包暴露包引用对象）
原型 - 任何对象的**proto** 属性指向他构造函数的 prototype，Object.prototype.**proto** = null 终点
typeof 值类型判断 instanceof 原型链判断（不能精确判断数组和对象） Object.prototype.toString.call(function () {});
commonjs 值拷贝、运行时加载，esmodule 是通过闭包暴露包引用对象 编译时输出，便于静态解析做依赖收集和 tree shaking
浏览器 URL 到显示页面：url->检查缓存->DNS 解析 -> ip -> tcp 链接到服务器获取数据 -> 渲染 html-> 解析 html 构建 DOM 树、解析 CSS 构建 CSS 树->合并 render 并布局。
V8 垃圾回收：标记清除，标记所有从根（比如全局变量）出发可以访问到的对象，剩下的未被标记的对象就是垃圾，所有清除他们释放内存。

React
react18: jsx-runtime、并发渲染的设计（useDeferredValue 标记不需要立刻更新的状态、 useTransition 标记非紧急更新）、Suspense
react 严格模式 故意双重渲染帮助发现副作用、过时的 API
vdom：跨平台、性能优化（比如列表最前面插入节点，通过 js 对象进行算法比对来知道我要插入一个 dom，否则就要都渲染）
事件委托合成事件：挂在根节点、减少事件创建挂载销毁、增加节点时不需要额外对 dom 挂载事件，统一事件处理方便跨端和兼容。
react-router:history、react context 全局路由状态、匹配路径和组件渲染
redux:单项数据流（可预测性、易于调试、数据流向清晰）、state 只读、状态修改由纯函数完成
reducer 返回一个新的 state(浅比较、深比较耗时性能吃不消)
hooks：逻辑复用能力（嵌套地狱）、解决生命周期碎片化、this 心智负担
hooks 单向链表存储，所以他必须保证调用顺序，不能再条件语句中使用 hook，顺序变化会导致单链表不可预测，状态错乱。
hooks 是顺序执行的，会检查当前的依赖项是否变化，如果变化了就要对当前 hook 重新计算和 effect 处理。
useMemo 缓存计算结果 useCallback 缓存函数引用：因为 hooks 是顺序执行的，每次状态变化函数要重新计算，尽量把不需要计算的通过 useMemo 缓存住，函数引用缓存住不要重新创建函数。
concurrent 模式：Fiber 单链表、可中断渲染、优先级调度、双缓冲机制。

构建 Fiber 单链表来实现分片渲染和任务优先级管理。fiber 在 render 阶段把任务分成多个小任务，每个任务执行前判断是否要让出主线程实现中断。（每次中断恢复会有本次执行任务的 deadline,通过当前时间与 deadline 时间戳比较判断）。

React 渲染过程包括以下步骤：
初始化时，调用 React.createElement 生成虚拟 DOM（VDOM），通过 协调（Reconciliation） 比对 VDOM 变化。
更新时，React 触发 setState 或 useState 变更，重新生成新的 VDOM，React Diff 算法比对差异，确定最小更新范围。
然后通过 提交阶段（Commit Phase），React 通过 DOM 操作或 React Native 组件渲染 UI，最终完成更新并触发副作用

小程序架构  
运行时：从基地到上层业务

- 容器、js-bridge、双线程模型
- 逻辑层（app、page、comp 实例，触发生命周期、函数调用、维护页面栈）
- 视图层（每个页面一个 html、挂载组件、页面渲染）
- 业务代码通过构建器解析成视图层、逻辑层分别注入。
- 上层模块系统加载 AMD 加载机制。 
  双线程模型：逻辑层、视图层，安全性、性能。适合重逻辑计算的业务。
  与单线程区别：架构区别，双线程具备安全性、性能，同样有架构复杂度，状态维护、消息通道、队列、状态更新同步的成本。
  通道：异步通信过程，容器消息 Bridge 桥接层中转消息，消息的序列化传递和反序列化，双线程两边各有一个消息队列用于消息处理。
  setData:逻辑层收集变更、对比差异、将最小差异传递到视图层，视图层接收到最小差异并更新虚拟 DOM，VDOM diff 后进行 patch 更新视图。
  AMD 安全性隔离机制，按需加载子包，webview 对 ESModule 支持度有限，体积小，精确控制包的加载，通过缓存管理优化加载性能，require 调用的时候才会加载模块，通过闭包注入安全沙箱进行 window 和 global 的阉割。 
  diff：react 简单 diff，到 vue 双端 diff+最长递增子序列进行优化。  双端对比：同事比较新旧节点的头部跟尾部，比如 旧 ABCD，新 ACED，比较头部 A，头指针到 1，再比较 尾部 D，尾指针到 E，最后处理 BC 和 CE，移动和创建删除节点。
  最长递增子序列：处理节点位置变化，找出相对位置不变的最长节点序列，只移动其他节点，这个递增子序列不动。
  小程序的 diff 算法也做了几个阶段的更新，第一阶段是使用的 React 的 diff 算法，从左到右，从上到下进行广度优先遍历节点并进行同级节点比较，子节点通过 key 值进行比对，这个算法是可以使用的，但是每次都要进行全树的完整 diff，而小程序又是完全的 Stack Reconciler，不能像 React 一样做 Fiber 分片更新节点，可能会造成线程卡顿。
  后面就更新成了 Vue2 用的双端对比算法，通过最长递增子序列优化，也是全树对比，只业务实践下来确实是双端对比算法更适合小程序，渲染耗时会小很多，大概 30% 的提升。
  因为涂鸦小程序大部分是设备控制的应用，组件树会包含大量的静态内容，比如不变的列表、文本、canvas，这些内容在 diff 算法中可以被快速识别为不变，不需要重新渲染，所以双端对比会更快一点。"
  后续的优化是准备配合构建器做静态提升（把不变的 DOM 结构提取出来）和补丁标记（只变更跟数据变化相关的部分），完全对齐 Vue3.0 的渲染流程。因为小程序基础库渲染底层变动影响比较大，setData 性能并不是完全瓶颈，这个目前就还没上线。

统一 API 层：抹平差异、向下兼容、错误处理、安全控制和权限管理
安全沙箱：AMD 和双线程
质量：变化少的底层包进行 95%+的单元测试，快照。
性能：性能监控、性能评分工具辅助。小程序包大小+体感耗时 P95

小程序构建器
template-compiler: 模板解析与编译：tokenizer 进行词法解析生成标记流（数组）、parser 进行语法分析构建 AST、AST 可以直接挂载在视图层、2.0 阶段做了 codeGenerator 生成可执行代码。
style-plugin:样式文件解析和加载、依赖管理（可能被循环引用，通过依赖收集做缓存）、less 、tyss 文件转化和优化（postcss 做平台兼容性、cssnano 代码压缩）、style-factory 标签转换器（防止与原生标签样式冲突）
webpack 开发服务器：在 webpack 项目中，我们有十个 js 文件。 在启动过程中，开发服务器会从头构建整个模块树，并打包生成浏览器可访问的一个项目。 在开发过程中，如果其中一个文件变更了，开发服务器会检测到这个文件的更改，并进行依赖图的重新构建，进行模块热替换（HMR）。
vite 开发态只是通过 esbuild 做 esm 转换，生产才打包。
esbuild go 底层语言比 JIT 快，多进程构建。
esbuild+swc 替换了 webpack+babel

TTT 能力
还有 API DSL 生态，API 业务开发通过一套 DSL 定义，生成 Android、iOS、小程序三端接口，保证了多端统一，这个 DSL 是基于 TS 的解析器，通过解析 DSL 中的自定义注解、函数注释、参数类型生成 API 元信息，再基于多端的模板注入生成 API 的接口代码，结合 CI 流程，也做了 AI 生成接口建议、自动生成文档、ts 类型等。
parser 解析注解、注释方法、事件、描述、生成元数据信息。
transform 转成 Android 、iOS、JS 的映射类型
generate：模板+代码生成
结合 CI 工具链：打包流程中生成 AI 提示、AI 纠错、API 历史版本、canIUse、文档、ts 类型并自动发布

Studio 低代码
帮助开发者快速验证设备控制方案，同时产品运营可以快速根据原型图拖拽出设备控制小程序对外发布。
Studio 核心编辑器+Sandbox 沙箱环境+moveable 拖拽交互+ark-extension 组件编辑器+组件库+插件系统（AI）+json2code+打包器

—————————
面试官，你好，我叫铉嘉伟，2015 年毕业于中北大学，信息与通信工程专业，15 年毕业开始工作到现在，近 10 年一直从事大前端相关工作。

目前就职于涂鸦智能，在涂鸦工作近五年的时间里，主要在公司跨端架构部门担任资深前端开发工程师，主要负责涂鸦小程序前端生态的开发。下面我会以涂鸦开发项目作为切入点，如果过程中您有问题，可以随时打断问我。

首先，涂鸦是做 IoT 平台的，任何开发者可以基于涂鸦的芯片做自己的智能化设备，并且可以使用涂鸦的设备控制相关 SDK，做自己的小应用，通过涂鸦 APP 进行设备控制，与家里的小米智能设备控制应用类似。在小程序项目启动前，涂鸦是通过 RN 来做的开发者生态，因为 RN 的一些生态问题，整个生态并不可控，所以需要一套 超级 App➕ 可以热更新的小应用，这样的完整生态来支撑开发者开发面板的需求。

小程序引擎，就是实现了一套类似微信小程序的底层框架，开发者可以开发任何小程序运行在我们提供的小程序容器上。这个项目我经历了 0-1 的开发，最开始我们选择的是 kraken，现在开源叫做 webf，这个项目是 react2flutter，flutter 实现了完整的 web 标准，可以把 web 端的产物直接在 flutter skia 上渲染。这个方案做了两个月坑太多了，后面换成了小程序引擎。小程序引擎涉及到的是容器通信、双线程引擎、组件层维护、API 层维护、业务代码的构建器、模块加载的 AMD 引擎。

基于小程序引擎还做了比如 React 跨端，因为涂鸦之前是 RN 的生态，内部业务和外部开发者的技术栈都是 React 为主，并且业务期望复用 RN 生态的物料，做了一套类似于 Taro、Remax 的跨端框架，使用 React 把代码运行在小程序双线程引擎上。这个框架是一个 React 运行时的框架，参考了 Remax 的框架，基于 Reconciler 将 React 渲染成一个 Vdom 树。再由 Ray 转成渲染树挂载在页面 data，最后触发小程序的模版渲染。

最近在做的一个项目是 Studio 低代码开发，用来推动小白通过拖拽的方式去生成一个设备控制应用，这个项目之前也是有一版 RN 的低代码平台，我们重新以小程序的运行时做了一版，目前运行了半年，大概数据有 300 左右的低代码生成的小程序。

还有 API DSL 生态，API 业务开发通过一套 DSL 定义，生成 Android、iOS、小程序三端接口，保证了多端统一，这个 DSL 是基于 TS 的解析器，通过解析 DSL 中的自定义注解、函数注释、参数类型生成 API 元信息，再基于多端的模板注入生成 API 的接口代码，结合 CI 流程，也做了 AI 生成接口建议、自动生成文档、ts 类型等。

其他的还有一些平台性质的，比如对外的小程序开发者平台、对内的管理后台、应用开发平台、性能指标数据埋点平台这些。

---

您好，我目前就职于 涂鸦智能，是 跨端架构 团队的一名资深前端开发工程师，团队规模大约 20 人。我毕业于 中北大学，拥有 信息与通信工程 学位。从大学到现在，我一直专注于大前端开发，积累了 10 年的相关经验。

在职业发展上，我对自己的方向有清晰的认知和规划。我是一个目标导向型的人，注重结果的同时也重视团队协作。在沟通方面，我善于表达自己的想法并倾听他人意见，能够有效地与不同背景的同事合作。

关于贵公司的 [产品/技术]，我之前已有一定的了解和实践经验。我非常欣赏贵公司在 [领域] 的创新和成就，这也是我希望加入的重要原因之一。

我相信自己能够在团队中充分发挥专业能力，为团队目标的达成贡献力量。同时，我也期待在这个环境中不断学习和成长，与团队共同进步。

以上是我的简要介绍，如果您有任何问题或想了解更多详情，请随时告诉我。

